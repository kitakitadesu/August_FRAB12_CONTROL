# Copyright 2016 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import rclpy
from rclpy.node import Node
import signal
from std_msgs.msg import Int32
import sys
import asyncio
import threading
import json
from http.server import HTTPServer, SimpleHTTPRequestHandler
import os
import tempfile
import socket
import time
from concurrent import futures
import grpc

# Import the generated gRPC files (will be generated by protoc)
try:
    from bocchi.proto import keyboard_pb2
    from bocchi.proto import keyboard_pb2_grpc
except ImportError:
    print("Error: gRPC files not found. Please generate them first using:")
    print("python -m grpc_tools.protoc --proto_path=bocchi/proto --python_out=bocchi/proto --grpc_python_out=bocchi/proto bocchi/proto/keyboard.proto")
    sys.exit(1)

minimal_publisher = None

def signal_handler(sig, frame):
    print("\nSIGINT (Ctrl+C) received! Performing graceful shutdown.")
    if minimal_publisher:
        minimal_publisher.destroy_node()
    rclpy.shutdown()
    sys.exit(0)

class KeyboardServicer(keyboard_pb2_grpc.KeyboardServiceServicer):
    """gRPC service implementation for keyboard input"""
    
    def __init__(self, publisher_node):
        self.publisher_node = publisher_node
        self.connected_clients = 0
        self.server_start_time = time.time()

    def SendKey(self, request, context):
        """Handle single key press"""
        try:
            # Extract key information
            key = request.key
            key_code = request.key_code
            timestamp = request.timestamp

            # Store the latest key for the ROS2 publisher
            self.publisher_node.latest_key = key_code

            print(f"Received key via gRPC: '{key}' (code: {key_code})")

            # Handle quit command
            if key.lower() == 'q':
                print("Quit command received - stopping publisher")
                # Signal shutdown in a separate thread to avoid blocking the gRPC response
                threading.Thread(target=lambda: os.kill(os.getpid(), signal.SIGINT), daemon=True).start()

            # Return success response
            return keyboard_pb2.KeyResponse(
                success=True,
                message=f"Key '{key}' processed successfully",
                timestamp=int(time.time() * 1000)
            )

        except Exception as e:
            print(f"Error processing key: {e}")
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(f"Error processing key: {str(e)}")
            return keyboard_pb2.KeyResponse(
                success=False,
                message=f"Error: {str(e)}",
                timestamp=int(time.time() * 1000)
            )

    def StreamKeys(self, request_iterator, context):
        """Handle streaming key presses (bidirectional streaming)"""
        try:
            self.connected_clients += 1
            client_address = context.peer()
            print(f"gRPC client connected for streaming from {client_address}. Total clients: {self.connected_clients}")

            # Send welcome message
            yield keyboard_pb2.KeyResponse(
                success=True,
                message="Connected to ROS2 Publisher Stream",
                timestamp=int(time.time() * 1000)
            )

            # Process incoming key stream
            for request in request_iterator:
                try:
                    key = request.key
                    key_code = request.key_code

                    # Store the latest key for the ROS2 publisher
                    self.publisher_node.latest_key = key_code

                    print(f"Received streamed key: '{key}' (code: {key_code}) from {client_address}")

                    # Handle quit command
                    if key.lower() == 'q':
                        print("Quit command received - stopping publisher")
                        yield keyboard_pb2.KeyResponse(
                            success=True,
                            message="Quit command received, shutting down",
                            timestamp=int(time.time() * 1000)
                        )
                        # Signal shutdown
                        threading.Thread(target=lambda: os.kill(os.getpid(), signal.SIGINT), daemon=True).start()
                        break

                    # Send acknowledgment
                    yield keyboard_pb2.KeyResponse(
                        success=True,
                        message=f"Key '{key}' processed successfully",
                        timestamp=int(time.time() * 1000)
                    )

                except Exception as e:
                    print(f"Error processing streamed key: {e}")
                    yield keyboard_pb2.KeyResponse(
                        success=False,
                        message=f"Error: {str(e)}",
                        timestamp=int(time.time() * 1000)
                    )

        except Exception as e:
            print(f"Stream error: {e}")
        finally:
            self.connected_clients -= 1
            print(f"gRPC streaming client {client_address} disconnected. Total clients: {self.connected_clients}")

    def GetStatus(self, request, context):
        """Get server status"""
        try:
            uptime = int(time.time() - self.server_start_time)
            return keyboard_pb2.StatusResponse(
                server_running=True,
                connected_clients=self.connected_clients,
                version="1.0.0",
                uptime=uptime
            )
        except Exception as e:
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(f"Error getting status: {str(e)}")
            return keyboard_pb2.StatusResponse(
                server_running=False,
                connected_clients=0,
                version="1.0.0",
                uptime=0
            )

class MinimalPublisher(Node):
    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(Int32, 'keyboard', 10)
        timer_period = 0.1  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.latest_key = None
        self.grpc_server = None

        # Check if ports are available
        self.check_ports()

        # Start the web server and gRPC server in separate threads
        self.start_web_server()
        self.start_grpc_server()

        print("=" * 50)
        print("ROS2 gRPC Keyboard Interface Started")
        print("=" * 50)
        print("Web interface: http://0.0.0.0:8000 (accessible from all network interfaces)")
        print("  - Local access: http://localhost:8000")
        print("  - Network access: http://<your-ip>:8000")
        print("gRPC server: 0.0.0.0:50051 (accessible from all network interfaces)")
        print("  - Local access: localhost:50051")
        print("  - Network access: <your-ip>:50051")
        print("Press any key in the web browser to publish to /keyboard topic")
        print("=" * 50)
        self.print_network_info()

    def check_ports(self):
        """Check if ports 8000 and 50051 are available"""
        def is_port_available(port):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.bind(('localhost', port))
                return True
            except socket.error:
                return False

        if not is_port_available(8000):
            print("WARNING: Port 8000 is already in use. HTTP server may not start.")
        if not is_port_available(50051):
            print("WARNING: Port 50051 is already in use. gRPC server may not start.")

    def print_network_info(self):
        """Print network diagnostic information"""
        try:
            # Get local IP address
            hostname = socket.gethostname()
            local_ip = socket.gethostbyname(hostname)
            print("\nNetwork Diagnostics:")
            print(f"  Hostname: {hostname}")
            print(f"  Local IP: {local_ip}")
            
            # Try to get more network interfaces
            try:
                import subprocess
                result = subprocess.run(['hostname', '-I'], capture_output=True, text=True, timeout=5)
                if result.returncode == 0:
                    ips = result.stdout.strip().split()
                    if ips:
                        print(f"  Available IPs: {', '.join(ips)}")
            except Exception:
                pass
                
            print("  Docker/Container IP range: 192.168.x.x, 172.x.x.x")
            print("  If connecting from host to container, use the container's IP")
            print()
        except Exception as e:
            print(f"Network diagnostics failed: {e}")

    def create_html_file(self):
        """Create the HTML file for keyboard input with gRPC client"""
        html_content = """
<!DOCTYPE html>
<html>
<head>
    <title>ROS2 gRPC Keyboard Input</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        .connected { background-color: #d4edda; color: #155724; }
        .disconnected { background-color: #f8d7da; color: #721c24; }
        .key-display {
            font-size: 24px;
            padding: 20px;
            margin: 20px 0;
            background-color: #e9ecef;
            border-radius: 5px;
            text-align: center;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .instructions {
            background-color: #cce7ff;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .debug-info {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        .warning {
            background-color: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ROS2 gRPC Keyboard Input Interface</h1>

        <div class="warning">
            <h3>⚠️ gRPC Web Client Notice</h3>
            <p><strong>This interface now uses gRPC instead of WebSocket.</strong></p>
            <p>Unfortunately, browsers cannot directly connect to gRPC servers. You have the following options:</p>
            <ul>
                <li><strong>Option 1:</strong> Use a gRPC client application (recommended)</li>
                <li><strong>Option 2:</strong> Use grpc-web with a proxy (requires additional setup)</li>
                <li><strong>Option 3:</strong> Use command line tools like grpcurl</li>
            </ul>
            <p>This page is provided for reference and testing purposes.</p>
        </div>

        <div class="instructions">
            <h3>gRPC Connection Information:</h3>
            <ul>
                <li><strong>Server Address:</strong> localhost:50051 (or your-ip:50051)</li>
                <li><strong>Service:</strong> keyboard.KeyboardService</li>
                <li><strong>Methods:</strong>
                    <ul>
                        <li>SendKey - Send a single key press</li>
                        <li>StreamKeys - Bidirectional streaming</li>
                        <li>GetStatus - Get server status</li>
                    </ul>
                </li>
            </ul>
        </div>

        <div class="instructions">
            <h3>Example gRPC Client Usage:</h3>
            <h4>Using grpcurl (install with: go install github.com/fullstorydev/grpcurl/cmd/grpcurl@latest)</h4>
            <pre style="background: #f8f9fa; padding: 10px; border-radius: 5px; overflow-x: auto;">
# Get server status
grpcurl -plaintext localhost:50051 keyboard.KeyboardService/GetStatus

# Send a key
grpcurl -plaintext -d '{"key": "a", "key_code": 97, "timestamp": 1234567890}' \\
  localhost:50051 keyboard.KeyboardService/SendKey
            </pre>

            <h4>Using Python gRPC Client:</h4>
            <pre style="background: #f8f9fa; padding: 10px; border-radius: 5px; overflow-x: auto;">
import grpc
from bocchi.proto import keyboard_pb2, keyboard_pb2_grpc

# Create channel and stub
channel = grpc.insecure_channel('localhost:50051')
stub = keyboard_pb2_grpc.KeyboardServiceStub(channel)

# Send a key
request = keyboard_pb2.KeyRequest(key='a', key_code=97, timestamp=1234567890)
response = stub.SendKey(request)
print(f"Response: {response.success}, {response.message}")
            </pre>
        </div>

        <div class="debug-info">
            <strong>Proto Definition Location:</strong><br>
            bocchi/proto/keyboard.proto<br><br>
            <strong>Generated Files:</strong><br>
            - bocchi/proto/keyboard_pb2.py<br>
            - bocchi/proto/keyboard_pb2_grpc.py<br><br>
            <strong>To generate gRPC files:</strong><br>
            python -m grpc_tools.protoc --proto_path=bocchi/proto --python_out=bocchi/proto --grpc_python_out=bocchi/proto bocchi/proto/keyboard.proto
        </div>
    </div>
</body>
</html>
        """

        # Create a temporary directory for the HTML file
        self.temp_dir = tempfile.mkdtemp()
        self.html_file = os.path.join(self.temp_dir, 'index.html')

        with open(self.html_file, 'w') as f:
            f.write(html_content)

        return self.temp_dir

    def start_web_server(self):
        """Start the HTTP server in a separate thread"""
        def run_server():
            try:
                # Change to the directory containing the HTML file
                os.chdir(self.create_html_file())

                class CustomHTTPRequestHandler(SimpleHTTPRequestHandler):
                    def log_message(self, format, *args):
                        # Only log errors
                        if '404' in str(args) or '500' in str(args):
                            print(f"HTTP Server: {format % args}")

                server = HTTPServer(('0.0.0.0', 8000), CustomHTTPRequestHandler)
                print("HTTP Server started successfully on port 8000")
                server.serve_forever()
            except Exception as e:
                print(f"Failed to start HTTP server: {e}")

        self.server_thread = threading.Thread(target=run_server, daemon=True)
        self.server_thread.start()

    def start_grpc_server(self):
        """Start the gRPC server in a separate thread"""
        def run_grpc_server():
            try:
                print("Initializing gRPC server...")
                
                # Create gRPC server
                self.grpc_server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
                
                # Add the service to the server
                keyboard_pb2_grpc.add_KeyboardServiceServicer_to_server(
                    KeyboardServicer(self), self.grpc_server
                )
                
                # Listen on all interfaces
                listen_addr = '0.0.0.0:50051'
                self.grpc_server.add_insecure_port(listen_addr)
                
                # Start the server
                self.grpc_server.start()
                print(f"✓ gRPC server started successfully on {listen_addr}")
                
                # Test connection after a brief delay
                time.sleep(1)
                
                try:
                    test_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    test_socket.settimeout(2)
                    result = test_socket.connect_ex(('127.0.0.1', 50051))
                    test_socket.close()
                    if result == 0:
                        print("✓ Port 50051 confirmed accessible")
                    else:
                        print(f"⚠ Port 50051 accessibility test failed: {result}")
                except Exception as test_e:
                    print(f"⚠ Port test error: {test_e}")
                
                print("gRPC server ready for connections")
                
                # Keep the server running
                try:
                    while True:
                        time.sleep(86400)  # Sleep for a day
                except KeyboardInterrupt:
                    print("gRPC server stopping...")
                    
            except Exception as e:
                print(f"✗ Failed to start gRPC server: {e}")
                import traceback
                traceback.print_exc()

        print("Starting gRPC server thread...")
        self.grpc_thread = threading.Thread(target=run_grpc_server, daemon=True)
        self.grpc_thread.start()

        # Give the server time to start
        print("Waiting for gRPC server to initialize...")
        time.sleep(2)

    def timer_callback(self):
        """Timer callback to publish the latest key"""
        if self.latest_key is not None:
            msg = Int32()
            msg.data = self.latest_key
            self.publisher_.publish(msg)
            self.get_logger().info(f'Publishing key code: {self.latest_key}')
            self.latest_key = None  # Clear the key after publishing

    def __del__(self):
        """Cleanup when the node is destroyed"""
        # Clean up gRPC server
        if hasattr(self, 'grpc_server') and self.grpc_server:
            try:
                self.grpc_server.stop(grace=5)
                print("gRPC server stopped")
            except:
                pass
        
        # Clean up temporary files
        if hasattr(self, 'temp_dir') and os.path.exists(self.temp_dir):
            import shutil
            shutil.rmtree(self.temp_dir)

def main(args=None):
    global minimal_publisher
    rclpy.init(args=args)
    signal.signal(signal.SIGINT, signal_handler)

    try:
        minimal_publisher = MinimalPublisher()
        rclpy.spin(minimal_publisher)
    except KeyboardInterrupt:
        print("\nShutdown requested by user")
    except Exception as e:
        print(f"Error in main: {e}")
        import traceback
        traceback.print_exc()
    finally:
        # Destroy the node explicitly
        if minimal_publisher:
            # Clean up gRPC server before destroying node
            if hasattr(minimal_publisher, 'grpc_server') and minimal_publisher.grpc_server:
                try:
                    minimal_publisher.grpc_server.stop(grace=5)
                    print("gRPC server stopped")
                except:
                    pass
            minimal_publisher.destroy_node()
        rclpy.shutdown()
        print("ROS2 node shutdown complete")

if __name__ == '__main__':
    main()