# Copyright 2016 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import rclpy
from rclpy.node import Node
import signal
from std_msgs.msg import String, Int32
import sys
import asyncio
import websockets
import threading
import json
from http.server import HTTPServer, SimpleHTTPRequestHandler
import os
import tempfile

minimal_publisher = None

def signal_handler(sig, frame):
    print("\nSIGINT (Ctrl+C) received! Performing graceful shutdown.")
    if minimal_publisher:
        minimal_publisher.destroy_node()
    rclpy.shutdown()
    sys.exit(0)

class MinimalPublisher(Node):
    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(Int32, 'keyboard', 10)
        timer_period = 0.1  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.latest_key = None
        self.websocket_clients = set()
        
        # Start the web server and websocket server in separate threads
        self.start_web_server()
        self.start_websocket_server()
        
        print("Web interface available at: http://localhost:8000")
        print("WebSocket server running on: ws://localhost:8765")

    def create_html_file(self):
        """Create the HTML file for keyboard input"""
        html_content = """
<!DOCTYPE html>
<html>
<head>
    <title>ROS2 Keyboard Input</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        .connected { background-color: #d4edda; color: #155724; }
        .disconnected { background-color: #f8d7da; color: #721c24; }
        .key-display {
            font-size: 24px;
            padding: 20px;
            margin: 20px 0;
            background-color: #e9ecef;
            border-radius: 5px;
            text-align: center;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .instructions {
            background-color: #cce7ff;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ROS2 Keyboard Input Interface</h1>
        
        <div id="status" class="status disconnected">
            Disconnected from WebSocket server
        </div>
        
        <div class="instructions">
            <h3>Instructions:</h3>
            <ul>
                <li>Click anywhere on this page to focus it</li>
                <li>Press any key to send it to the ROS2 publisher</li>
                <li>Press 'q' to quit the publisher</li>
                <li>The key code will be published to the 'keyboard' topic</li>
            </ul>
        </div>
        
        <div class="key-display" id="keyDisplay">
            Press any key...
        </div>
        
        <div id="log"></div>
    </div>

    <script>
        let socket = null;
        let connected = false;
        
        function updateStatus(isConnected) {
            const statusDiv = document.getElementById('status');
            connected = isConnected;
            if (isConnected) {
                statusDiv.textContent = 'Connected to WebSocket server';
                statusDiv.className = 'status connected';
            } else {
                statusDiv.textContent = 'Disconnected from WebSocket server';
                statusDiv.className = 'status disconnected';
            }
        }
        
        function connectWebSocket() {
            try {
                socket = new WebSocket('ws://localhost:8765');
                
                socket.onopen = function(event) {
                    console.log('Connected to WebSocket server');
                    updateStatus(true);
                };
                
                socket.onclose = function(event) {
                    console.log('Disconnected from WebSocket server');
                    updateStatus(false);
                    // Try to reconnect after 3 seconds
                    setTimeout(connectWebSocket, 3000);
                };
                
                socket.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    updateStatus(false);
                };
                
                socket.onmessage = function(event) {
                    console.log('Received:', event.data);
                };
            } catch (error) {
                console.error('Failed to connect to WebSocket:', error);
                updateStatus(false);
                setTimeout(connectWebSocket, 3000);
            }
        }
        
        function sendKey(key, keyCode) {
            if (connected && socket && socket.readyState === WebSocket.OPEN) {
                const message = {
                    key: key,
                    keyCode: keyCode,
                    timestamp: Date.now()
                };
                socket.send(JSON.stringify(message));
                
                // Update display
                const keyDisplay = document.getElementById('keyDisplay');
                keyDisplay.innerHTML = `
                    <div>
                        <div>Key: "${key}"</div>
                        <div>Code: ${keyCode}</div>
                    </div>
                `;
                
                console.log('Sent key:', key, 'Code:', keyCode);
            } else {
                console.log('WebSocket not connected, cannot send key');
            }
        }
        
        // Handle keyboard events
        document.addEventListener('keydown', function(event) {
            event.preventDefault(); // Prevent default browser behavior
            
            let key = event.key;
            let keyCode = event.keyCode || event.which;
            
            // Handle special keys
            if (key === 'ArrowUp') key = 'UP';
            else if (key === 'ArrowDown') key = 'DOWN';
            else if (key === 'ArrowLeft') key = 'LEFT';
            else if (key === 'ArrowRight') key = 'RIGHT';
            else if (key === ' ') key = 'SPACE';
            else if (key === 'Enter') key = 'ENTER';
            else if (key === 'Escape') key = 'ESC';
            else if (key === 'Backspace') key = 'BACKSPACE';
            else if (key === 'Tab') key = 'TAB';
            
            sendKey(key, keyCode);
        });
        
        // Make sure the page can receive keyboard events
        document.addEventListener('click', function() {
            document.body.focus();
        });
        
        // Connect to WebSocket when page loads
        window.addEventListener('load', function() {
            connectWebSocket();
            document.body.focus(); // Focus the body to receive keyboard events
        });
    </script>
</body>
</html>
        """
        
        # Create a temporary directory for the HTML file
        self.temp_dir = tempfile.mkdtemp()
        self.html_file = os.path.join(self.temp_dir, 'index.html')
        
        with open(self.html_file, 'w') as f:
            f.write(html_content)
        
        return self.temp_dir

    def start_web_server(self):
        """Start the HTTP server in a separate thread"""
        def run_server():
            # Change to the directory containing the HTML file
            os.chdir(self.create_html_file())
            
            class CustomHTTPRequestHandler(SimpleHTTPRequestHandler):
                def log_message(self, format, *args):
                    # Suppress HTTP server logs
                    pass
            
            server = HTTPServer(('localhost', 8000), CustomHTTPRequestHandler)
            server.serve_forever()
        
        self.server_thread = threading.Thread(target=run_server, daemon=True)
        self.server_thread.start()

    def start_websocket_server(self):
        """Start the WebSocket server in a separate thread"""
        def run_websocket_server():
            async def handle_client(websocket, path):
                self.websocket_clients.add(websocket)
                print(f"Client connected. Total clients: {len(self.websocket_clients)}")
                
                try:
                    async for message in websocket:
                        try:
                            data = json.loads(message)
                            key = data.get('key', '')
                            key_code = data.get('keyCode', 0)
                            
                            # Store the latest key for the ROS2 publisher
                            self.latest_key = key_code
                            
                            print(f"Received key: '{key}' (code: {key_code})")
                            
                            # Handle quit command
                            if key.lower() == 'q':
                                print("Quit command received")
                                # You can add graceful shutdown logic here
                                
                        except json.JSONDecodeError:
                            print(f"Invalid JSON received: {message}")
                            
                except websockets.exceptions.ConnectionClosed:
                    pass
                finally:
                    self.websocket_clients.discard(websocket)
                    print(f"Client disconnected. Total clients: {len(self.websocket_clients)}")
            
            async def start_server():
                server = await websockets.serve(handle_client, "localhost", 8765)
                print("WebSocket server started on ws://localhost:8765")
                await server.wait_closed()
            
            # Run the websocket server
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            loop.run_until_complete(start_server())
        
        self.websocket_thread = threading.Thread(target=run_websocket_server, daemon=True)
        self.websocket_thread.start()

    def timer_callback(self):
        """Timer callback to publish the latest key"""
        if self.latest_key is not None:
            msg = Int32()
            msg.data = self.latest_key
            self.publisher_.publish(msg)
            self.get_logger().info(f'Publishing key code: {self.latest_key}')
            self.latest_key = None  # Clear the key after publishing

    def __del__(self):
        """Cleanup when the node is destroyed"""
        # Clean up temporary files
        if hasattr(self, 'temp_dir') and os.path.exists(self.temp_dir):
            import shutil
            shutil.rmtree(self.temp_dir)

def main(args=None):
    global minimal_publisher
    rclpy.init(args=args)
    signal.signal(signal.SIGINT, signal_handler)
    minimal_publisher = MinimalPublisher()

    try:
        rclpy.spin(minimal_publisher)
    except KeyboardInterrupt:
        pass
    finally:
        # Destroy the node explicitly
        if minimal_publisher:
            minimal_publisher.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()